"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keychain = exports.updateAuthEntry = exports.newAuthEntry = void 0;
const dids_1 = require("dids");
const key_did_provider_ed25519_1 = require("key-did-provider-ed25519");
const key_did_resolver_1 = __importDefault(require("key-did-resolver"));
const keyring_1 = __importStar(require("./keyring"));
const utils_1 = require("./utils");
function decryptAuthId(encrypted, keyring) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!encrypted.jwe)
            throw new Error('Invalid encrypted block');
        const decrypted = yield keyring.asymDecryptJWE(encrypted.jwe, utils_1.parseJWEKids(encrypted.jwe));
        return decrypted.id;
    });
}
const encrypter = new dids_1.DID({ resolver: key_did_resolver_1.default.getResolver() });
function authSecretToDID(authSecret) {
    return __awaiter(this, void 0, void 0, function* () {
        const did = new dids_1.DID({
            provider: new key_did_provider_ed25519_1.Ed25519Provider(authSecret),
            resolver: key_did_resolver_1.default.getResolver(),
        });
        yield did.authenticate();
        return did;
    });
}
function newAuthEntry(keyring, threeIdDid, authId, authSecret) {
    return __awaiter(this, void 0, void 0, function* () {
        const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;
        const did = yield authSecretToDID(authSecret);
        const cleartext = { seed: keyring.seed };
        if (keyring.v03ID)
            cleartext.v03ID = keyring.v03ID;
        const resolvedPromises = yield Promise.all([
            did.createDagJWE(cleartext, [did.id]),
            keyring.asymEncryptJWE({ id: authId }, mainKid),
        ]);
        return {
            did,
            mapEntry: {
                [did.id]: {
                    data: { jwe: resolvedPromises[0] },
                    id: { jwe: resolvedPromises[1] },
                },
            },
        };
    });
}
exports.newAuthEntry = newAuthEntry;
function updateAuthEntry(keyring, authEntry, removedAuthIds, threeIdDid, authDid) {
    return __awaiter(this, void 0, void 0, function* () {
        const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;
        const authId = yield decryptAuthId(authEntry.id, keyring);
        if (removedAuthIds.find((id) => id === authId))
            return null;
        const jwes = yield Promise.all([
            encrypter.createDagJWE({ seed: keyring.seed }, [authDid]),
            keyring.asymEncryptJWE({ id: authId }, mainKid),
        ]);
        return {
            data: { jwe: jwes[0] },
            id: { jwe: jwes[1] },
        };
    });
}
exports.updateAuthEntry = updateAuthEntry;
function rotateKeys(threeIdx, keyring, removedAuthIds) {
    return __awaiter(this, void 0, void 0, function* () {
        const version = threeIdx.get3idVersion();
        yield keyring.generateNewKeys(version);
        const update3idState = keyring.get3idState();
        const authMap = threeIdx.getAuthMap();
        const newAuthMap = {};
        yield Promise.all(Object.keys(authMap).map((authDid) => __awaiter(this, void 0, void 0, function* () {
            const entry = yield updateAuthEntry(keyring, authMap[authDid], removedAuthIds, threeIdx.id, authDid);
            if (entry) {
                newAuthMap[authDid] = entry;
            }
        })));
        yield threeIdx.rotateKeys(update3idState, keyring.pastSeeds, newAuthMap);
    });
}
class Keychain {
    constructor(_keyring, _threeIdx) {
        this._keyring = _keyring;
        this._threeIdx = _threeIdx;
        this._pendingAdds = [];
        this._pendingRms = [];
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(Object.values(this._threeIdx.getAuthMap()).map(({ id }) => __awaiter(this, void 0, void 0, function* () {
                return decryptAuthId(id, this._keyring);
            })));
        });
    }
    add(authId, authSecret) {
        return __awaiter(this, void 0, void 0, function* () {
            this._pendingAdds.push({
                authId,
                entry: yield newAuthEntry(this._keyring, this._threeIdx.id, authId, authSecret),
            });
        });
    }
    remove(authId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._pendingRms.push(authId);
        });
    }
    status() {
        return {
            clean: !(this._pendingAdds.length + this._pendingRms.length),
            adding: this._pendingAdds.map((e) => e.authId),
            removing: this._pendingRms,
        };
    }
    commit() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._pendingAdds.length && !this._pendingRms.length)
                throw new Error('Nothing to commit');
            if (Object.keys(this._threeIdx.getAuthMap()).length === 0) {
                if (this._pendingRms.length)
                    throw new Error('Can not remove non-existent auth method');
                if (!this._pendingAdds.length)
                    throw new Error('Can not add non-existent auth method');
                yield this._threeIdx.createIDX((_a = this._pendingAdds.pop()) === null || _a === void 0 ? void 0 : _a.entry);
            }
            if (this._pendingRms.length) {
                yield rotateKeys(this._threeIdx, this._keyring, this._pendingRms);
                this._pendingRms = [];
            }
            if (this._pendingAdds.length) {
                const entries = this._pendingAdds.map((e) => e.entry);
                this._pendingAdds = [];
                yield this._threeIdx.addAuthEntries(entries);
            }
        });
    }
    static load(threeIdx, authSecret, makeTmpProvider) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const did = yield authSecretToDID(authSecret);
            const authData = yield threeIdx.loadIDX(did.id);
            if (authData) {
                if (!((_a = authData.seed) === null || _a === void 0 ? void 0 : _a.jwe))
                    throw new Error('Unable to find auth data');
                try {
                    const decrypted = yield did.decryptDagJWE(authData.seed.jwe);
                    const keyring = new keyring_1.default(new Uint8Array(decrypted.seed), decrypted.v03ID);
                    yield keyring.loadPastSeeds(authData.pastSeeds);
                    if (keyring.v03ID)
                        yield threeIdx.create3idDoc(keyring.get3idState(true));
                    return new Keychain(keyring, threeIdx);
                }
                catch (e) {
                    if (e.message === 'Failed to decrypt')
                        throw new Error('Auth not allowed');
                    throw e;
                }
            }
            return Keychain.create(threeIdx, makeTmpProvider);
        });
    }
    static loadFromSeed(threeIdx, seed, did, makeTmpProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = new keyring_1.default(seed);
            yield threeIdx.loadAllDocs(did);
            yield threeIdx.setDIDProvider(makeTmpProvider(keyring, did));
            return new Keychain(keyring, threeIdx);
        });
    }
    static create(threeIdx, makeTmpProvider, seed, v03ID) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = new keyring_1.default(seed, v03ID);
            const docParams = keyring.get3idState(true);
            yield threeIdx.setDIDProvider(makeTmpProvider(keyring, docParams.metadata.controllers[0]));
            yield threeIdx.create3idDoc(docParams);
            if (v03ID)
                threeIdx.setV03ID(v03ID);
            return new Keychain(keyring, threeIdx);
        });
    }
}
exports.Keychain = Keychain;
//# sourceMappingURL=keychain.js.map