"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreeIDX = void 0;
const common_1 = require("@ceramicnetwork/common");
const stream_tile_1 = require("@ceramicnetwork/stream-tile");
const http_client_1 = __importDefault(require("@ceramicnetwork/http-client"));
const idx_constants_1 = require("@ceramicstudio/idx-constants");
const cids_1 = __importDefault(require("cids"));
const key_did_resolver_1 = __importDefault(require("key-did-resolver"));
const _3id_did_resolver_1 = __importDefault(require("@ceramicnetwork/3id-did-resolver"));
const did_resolver_1 = require("did-resolver");
const dids_1 = require("dids");
const KEYCHAIN_DEF = idx_constants_1.definitions.threeIdKeychain;
const IDX = 'IDX';
const { IdentityIndex, ThreeIdKeychain } = idx_constants_1.schemas;
const isLegacyDid = (didId) => {
    try {
        new cids_1.default(didId);
        return true;
    }
    catch (e) {
        return false;
    }
};
class ThreeIDX {
    constructor(ceramic) {
        this.ceramic = ceramic || new http_client_1.default();
        this.docs = {};
        this._subscriptionSet = new common_1.SubscriptionSet();
    }
    setDIDProvider(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyDidResolver = key_did_resolver_1.default.getResolver();
            const threeIdResolver = _3id_did_resolver_1.default.getResolver(this.ceramic);
            const resolver = new did_resolver_1.Resolver(Object.assign(Object.assign({}, threeIdResolver), keyDidResolver));
            const did = new dids_1.DID({ provider, resolver });
            yield did.authenticate();
            yield this.ceramic.setDID(did);
        });
    }
    setV03ID(did) {
        this._v03ID = did;
    }
    get id() {
        return this._v03ID || `did:3:${this.docs.threeId.id.baseID.toString()}`;
    }
    create3idDoc(docParams) {
        return __awaiter(this, void 0, void 0, function* () {
            this.docs.threeId = yield stream_tile_1.TileDocument.create(this.ceramic, docParams.content, docParams.metadata, {
                anchor: false,
                publish: false,
            });
            this._subscriptionSet.add(this.docs.threeId.subscribe());
        });
    }
    get3idVersion() {
        const anchorCommitIds = this.docs.threeId.anchorCommitIds;
        const docId = anchorCommitIds[anchorCommitIds.length - 1];
        return docId ? docId.commit.toString() : '0';
    }
    loadDoc(name, controller, family) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = yield stream_tile_1.TileDocument.create(this.ceramic, null, { controllers: [controller], family: family, deterministic: true }, { anchor: false, publish: false });
            this.docs[name] = stream;
            this._subscriptionSet.add(stream.subscribe());
            return stream;
        });
    }
    createAuthLinkUpdate({ did }) {
        return __awaiter(this, void 0, void 0, function* () {
            const didString = did.id;
            const tile = yield this.loadDoc(didString, didString, 'authLink');
            yield this.ceramic.pin.add(tile.id);
            const commit = yield tile.makeCommit({ did }, { did: this.id });
            return {
                commit: commit,
                docid: tile.id,
                did: didString,
            };
        });
    }
    applyAuthLinkUpdate({ docid, commit, did }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.docs[did].content !== this.id) {
                yield this.ceramic.applyCommit(docid, commit);
                yield this.docs[did].sync();
            }
        });
    }
    createIDX(newEntry) {
        return __awaiter(this, void 0, void 0, function* () {
            const docUpdatePromise = newEntry ? this.createAuthLinkUpdate(newEntry) : Promise.resolve(null);
            yield Promise.all([
                this.loadDoc(KEYCHAIN_DEF, this.id, KEYCHAIN_DEF),
                this.loadDoc('idx', this.id, IDX),
            ]);
            yield Promise.all([
                this.pinAllDocs(),
                this.updateKeychainDoc(newEntry === null || newEntry === void 0 ? void 0 : newEntry.mapEntry),
                this.addKeychainToIDX(),
            ]);
            const docUpdate = yield docUpdatePromise;
            if (docUpdate) {
                yield this.applyAuthLinkUpdate(docUpdate);
            }
        });
    }
    loadIDX(authDid) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadDoc(authDid, authDid, 'authLink');
            const { did } = this.docs[authDid].content;
            if (!did)
                return null;
            yield this.loadAllDocs(did);
            const { authMap, pastSeeds } = this.docs[KEYCHAIN_DEF].content;
            return {
                seed: (_a = authMap[authDid]) === null || _a === void 0 ? void 0 : _a.data,
                pastSeeds,
            };
        });
    }
    loadAllDocs(did) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this.load3IDDoc(did),
                this.loadDoc(KEYCHAIN_DEF, did, KEYCHAIN_DEF),
                this.loadDoc('idx', did, IDX),
            ]);
        });
    }
    load3IDDoc(did) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = did.split(':')[2];
            if (isLegacyDid(id)) {
                this._v03ID = did;
            }
            else {
                this.docs.threeId = yield this.ceramic.loadStream(id);
                this._subscriptionSet.add(this.docs.threeId.subscribe());
            }
        });
    }
    addAuthEntries(newEntries) {
        return __awaiter(this, void 0, void 0, function* () {
            const linkDocUpdatesPromise = Promise.all(newEntries.map(this.createAuthLinkUpdate.bind(this)));
            const { authMap, pastSeeds } = this.docs[KEYCHAIN_DEF].content;
            const newAuthEntries = newEntries.reduce((acc, { mapEntry }) => Object.assign(acc, mapEntry), {});
            Object.assign(authMap, newAuthEntries);
            yield this.updateKeychainDoc(authMap, pastSeeds);
            yield Promise.all((yield linkDocUpdatesPromise).map(this.applyAuthLinkUpdate.bind(this)));
        });
    }
    getAuthMap() {
        if (!this.docs[KEYCHAIN_DEF] || !this.docs[KEYCHAIN_DEF].content.authMap)
            return {};
        return this.docs[KEYCHAIN_DEF].content.authMap;
    }
    pinAllDocs() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(Object.values(this.docs).map((doc) => __awaiter(this, void 0, void 0, function* () {
                yield this.ceramic.pin.add(doc.id);
            })));
        });
    }
    addKeychainToIDX() {
        return __awaiter(this, void 0, void 0, function* () {
            const content = this.docs.idx.content;
            if (!content || !content[KEYCHAIN_DEF]) {
                const nextContent = Object.assign(content || {}, {
                    [KEYCHAIN_DEF]: this.docs[KEYCHAIN_DEF].id.toUrl(),
                });
                const nextMetadata = this.docs.idx.metadata.schema ? undefined : { schema: IdentityIndex };
                yield this.docs.idx.update(nextContent, nextMetadata);
            }
        });
    }
    updateKeychainDoc(authMap = {}, pastSeeds = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.keys(authMap).length !== 0) {
                const update = { content: { authMap, pastSeeds } };
                if (!this.docs[KEYCHAIN_DEF].metadata.schema) {
                    update.metadata = { schema: ThreeIdKeychain };
                }
                yield this.docs[KEYCHAIN_DEF].update(update.content, update.metadata);
                yield this.docs[KEYCHAIN_DEF].sync();
            }
        });
    }
    rotateKeys(threeIdState, pastSeeds, authMap) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!threeIdState.content)
                throw new Error('Content has to be defined');
            const currentController = this.docs.threeId.controllers[0];
            const didKey = new Proxy(this.ceramic.did, {
                get(target, prop, receiver) {
                    if (prop === 'createJWS') {
                        return (payload, options = {}) => {
                            return target.createJWS(payload, Object.assign({}, options, { did: currentController }));
                        };
                    }
                    else {
                        return Reflect.get(target, prop, receiver);
                    }
                },
            });
            const originalDid = this.ceramic.did;
            this.ceramic.did = didKey;
            yield this.docs.threeId.update(Object.assign(Object.assign({}, this.docs.threeId.content), { publicKeys: threeIdState.content.publicKeys }), threeIdState.metadata);
            this.ceramic.did = originalDid;
            yield Promise.all([this.updateKeychainDoc(authMap, pastSeeds), this.pinAllDocs()]);
        });
    }
}
exports.ThreeIDX = ThreeIDX;
//# sourceMappingURL=three-idx.js.map