"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const u8a = __importStar(require("uint8arrays"));
const random_1 = require("@stablelib/random");
const keychain_1 = require("../keychain");
const keyring_1 = __importDefault(require("../keyring"));
const seed = u8a.fromString('8e641c0dc77f6916cc7f743dad774cdf9f6f7bcb880b11395149dd878377cd398650bbfd4607962b49953c87da4d7f3ff247ed734b06f96bdd69479377bc612b', 'base16');
const randomAuthSecret = () => random_1.randomBytes(32);
const makeTmpProvider = jest.fn();
describe('Keychain', () => {
    let keyring;
    let threeIdx;
    beforeAll(() => {
        keyring = new keyring_1.default(seed);
    });
    beforeEach(() => {
        const authMap = {};
        threeIdx = {
            id: 'did:3:asdf',
            loadIDX: jest.fn(() => Promise.resolve(null)),
            setDIDProvider: jest.fn(),
            create3idDoc: jest.fn(),
            createIDX: jest.fn((entry) => {
                Object.assign(authMap, entry.mapEntry);
                return Promise.resolve();
            }),
            addAuthEntries: jest.fn((entries) => {
                entries.map((entry) => Object.assign(authMap, entry.mapEntry));
                return Promise.resolve();
            }),
            getAuthMap: jest.fn(() => authMap),
            get3idVersion: jest.fn(() => '0'),
            rotateKeys: jest.fn(),
            setV03ID: jest.fn(),
        };
    });
    it('Create with v03ID', () => __awaiter(void 0, void 0, void 0, function* () {
        const v03ID = 'did:3:abc234';
        const keychain = yield keychain_1.Keychain.create(threeIdx, makeTmpProvider, randomAuthSecret(), v03ID);
        expect(threeIdx.setDIDProvider).toHaveBeenCalledTimes(1);
        expect(threeIdx.create3idDoc).toHaveBeenCalledTimes(1);
        expect(threeIdx.setV03ID).toHaveBeenCalledTimes(1);
        expect(threeIdx.setV03ID).toHaveBeenCalledWith(v03ID);
        expect(yield keychain.list()).toEqual([]);
        expect(keychain._keyring.v03ID).toEqual(v03ID);
    }));
    it('load, no IDX present', () => __awaiter(void 0, void 0, void 0, function* () {
        const keychain = yield keychain_1.Keychain.load(threeIdx, randomAuthSecret(), makeTmpProvider);
        expect(threeIdx.loadIDX).toHaveBeenCalledTimes(1);
        expect(threeIdx.setDIDProvider).toHaveBeenCalledTimes(1);
        expect(threeIdx.create3idDoc).toHaveBeenCalledTimes(1);
        expect(threeIdx.setV03ID).toHaveBeenCalledTimes(0);
        expect(yield keychain.list()).toEqual([]);
    }));
    it('load, IDX present', () => __awaiter(void 0, void 0, void 0, function* () {
        const authSecret = randomAuthSecret();
        const tmpKc = yield keychain_1.Keychain.load(threeIdx, authSecret, makeTmpProvider);
        const newEntry = yield keychain_1.newAuthEntry(tmpKc._keyring, threeIdx.id, 'authid', authSecret);
        yield threeIdx.createIDX(newEntry);
        threeIdx.loadIDX = jest.fn(() => Promise.resolve({
            seed: threeIdx.getAuthMap()[newEntry.did.id].data,
            pastSeeds: [],
        }));
        const keychain = yield keychain_1.Keychain.load(threeIdx, authSecret, makeTmpProvider);
        expect(threeIdx.loadIDX).toHaveBeenCalledTimes(1);
        expect(yield keychain.list()).toEqual(['authid']);
    }));
    it('load, IDX present, v03ID', () => __awaiter(void 0, void 0, void 0, function* () {
        const v03ID = 'did:3:abc234';
        const authSecret = randomAuthSecret();
        const keychain = yield keychain_1.Keychain.create(threeIdx, makeTmpProvider, randomAuthSecret(), v03ID);
        expect(threeIdx.setV03ID).toHaveBeenCalledTimes(1);
        expect(threeIdx.create3idDoc).toHaveBeenCalledTimes(1);
        yield keychain.add('auth1', authSecret);
        yield keychain.commit();
        threeIdx.loadIDX = jest.fn(() => Promise.resolve({
            seed: Object.values(threeIdx.getAuthMap())[0].data,
            pastSeeds: keychain._keyring.pastSeeds,
        }));
        const keychain1 = yield keychain_1.Keychain.load(threeIdx, authSecret, makeTmpProvider);
        expect(threeIdx.create3idDoc).toHaveBeenCalledTimes(2);
        expect(keychain1._keyring.v03ID).toEqual(v03ID);
    }));
    it('commit adds, no IDX created yet', () => __awaiter(void 0, void 0, void 0, function* () {
        const keychain = new keychain_1.Keychain(keyring, threeIdx);
        expect(threeIdx.createIDX).toHaveBeenCalledTimes(0);
        yield keychain.add('auth1', randomAuthSecret());
        yield keychain.add('auth2', randomAuthSecret());
        expect(yield keychain.list()).toEqual([]);
        yield keychain.commit();
        expect(threeIdx.createIDX).toHaveBeenCalledTimes(1);
        expect(threeIdx.addAuthEntries).toHaveBeenCalledTimes(1);
        expect(threeIdx.addAuthEntries).toHaveBeenCalledTimes(1);
        expect(yield keychain.list()).toEqual(['auth2', 'auth1']);
    }));
    it('commit adds, IDX already created', () => __awaiter(void 0, void 0, void 0, function* () {
        const keychain = new keychain_1.Keychain(keyring, threeIdx);
        yield threeIdx.createIDX(yield keychain_1.newAuthEntry(keychain._keyring, threeIdx.id, 'authid', randomAuthSecret()));
        yield keychain.add('auth1', randomAuthSecret());
        yield keychain.add('auth2', randomAuthSecret());
        expect(yield keychain.list()).toEqual(['authid']);
        yield keychain.commit();
        expect(threeIdx.createIDX).toHaveBeenCalledTimes(1);
        expect(threeIdx.addAuthEntries).toHaveBeenCalledTimes(1);
        expect(yield keychain.list()).toEqual(['authid', 'auth1', 'auth2']);
    }));
    it('commit removes', () => __awaiter(void 0, void 0, void 0, function* () {
        const authSecret0 = randomAuthSecret();
        const authSecret1 = randomAuthSecret();
        const rotateKeys = jest.fn();
        threeIdx.rotateKeys = rotateKeys;
        const keychain = new keychain_1.Keychain(keyring, threeIdx);
        yield threeIdx.createIDX(yield keychain_1.newAuthEntry(keychain._keyring, threeIdx.id, 'authid', authSecret0));
        yield keychain.add('auth1', authSecret1);
        yield keychain.commit();
        yield keychain.remove('authid');
        expect(yield keychain.list()).toEqual(['authid', 'auth1']);
        yield keychain.commit();
        threeIdx.loadIDX = jest.fn(() => Promise.resolve({
            seed: Object.values(rotateKeys.mock.calls[0][2])[0].data,
            pastSeeds: rotateKeys.mock.calls[0][1],
        }));
        yield expect(keychain_1.Keychain.load(threeIdx, authSecret1, makeTmpProvider)).resolves.toBeTruthy();
        yield expect(keychain_1.Keychain.load(threeIdx, authSecret0, makeTmpProvider)).rejects.toThrow('Auth not allowed');
    }));
    it('add updates status', () => __awaiter(void 0, void 0, void 0, function* () {
        const keychain = yield keychain_1.Keychain.load(threeIdx, randomAuthSecret(), makeTmpProvider);
        expect(keychain.status()).toEqual({ clean: true, adding: [], removing: [] });
        yield keychain.add('auth1', randomAuthSecret());
        yield keychain.add('auth2', randomAuthSecret());
        expect(keychain.status()).toEqual({
            clean: false,
            adding: ['auth1', 'auth2'],
            removing: [],
        });
        yield keychain.add('auth3', randomAuthSecret());
        expect(keychain.status()).toEqual({
            clean: false,
            adding: ['auth1', 'auth2', 'auth3'],
            removing: [],
        });
    }));
    it('remove updates status', () => __awaiter(void 0, void 0, void 0, function* () {
        const keychain = yield keychain_1.Keychain.load(threeIdx, randomAuthSecret(), makeTmpProvider);
        expect(keychain.status()).toEqual({ clean: true, adding: [], removing: [] });
        yield keychain.remove('auth1');
        yield keychain.remove('auth2');
        expect(keychain.status()).toEqual({
            clean: false,
            adding: [],
            removing: ['auth1', 'auth2'],
        });
        yield keychain.remove('auth3');
        expect(keychain.status()).toEqual({
            clean: false,
            adding: [],
            removing: ['auth1', 'auth2', 'auth3'],
        });
    }));
});
//# sourceMappingURL=keychain.test.js.map