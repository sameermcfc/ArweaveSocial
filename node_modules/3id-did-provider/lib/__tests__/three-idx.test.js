"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tmp_promise_1 = __importDefault(require("tmp-promise"));
const core_1 = __importDefault(require("@ceramicnetwork/core"));
const dids_1 = require("dids");
const key_did_provider_ed25519_1 = require("key-did-provider-ed25519");
const key_did_resolver_1 = __importDefault(require("key-did-resolver"));
const ipfs_1 = __importDefault(require("ipfs"));
const it_all_1 = __importDefault(require("it-all"));
const idx_constants_1 = require("@ceramicstudio/idx-constants");
const idx_tools_1 = require("@ceramicstudio/idx-tools");
const random_1 = require("@stablelib/random");
const _3id_did_resolver_1 = __importDefault(require("@ceramicnetwork/3id-did-resolver"));
const three_idx_1 = require("../three-idx");
const did_provider_1 = require("../did-provider");
const keyring_1 = __importDefault(require("../keyring"));
const dag_jose_1 = __importDefault(require("dag-jose"));
const sha2_1 = require("multiformats/hashes/sha2");
const legacy_1 = __importDefault(require("multiformats/legacy"));
const u8a = __importStar(require("uint8arrays"));
const key_did_resolver_2 = __importDefault(require("key-did-resolver"));
const seed = u8a.fromString('8e641c0dc77f6916cc7f743dad774cdf9f6f7bcb880b11395149dd878377cd398650bbfd4607962b49953c87da4d7f3ff247ed734b06f96bdd69479377bc612b', 'base16');
const KEYCHAIN_DEF = idx_constants_1.definitions.threeIdKeychain;
const genIpfsConf = (folder) => {
    const hasher = {};
    hasher[sha2_1.sha256.code] = sha2_1.sha256;
    const format = legacy_1.default(dag_jose_1.default, { hashes: hasher });
    return {
        ipld: { formats: [format] },
        repo: `${folder}/ipfs/`,
        config: {
            Addresses: { Swarm: [] },
            Bootstrap: [],
        },
        silent: true,
    };
};
const randomSecret = () => '0x' + Buffer.from(random_1.randomBytes(32)).toString('hex');
const pauseSeconds = (sec) => new Promise((res) => setTimeout(res, sec * 1000));
const fakeJWE = () => ({
    jwe: {
        protected: 'prot',
        tag: 'tag',
        ciphertext: randomSecret(),
        iv: 'iv',
    },
});
function genAuthEntryCreate() {
    return __awaiter(this, void 0, void 0, function* () {
        const provider = new key_did_provider_ed25519_1.Ed25519Provider(random_1.randomBytes(32));
        const did = new dids_1.DID({ provider, resolver: key_did_resolver_1.default.getResolver() });
        yield did.authenticate();
        return {
            did,
            mapEntry: {
                [did.id]: {
                    data: fakeJWE(),
                    id: fakeJWE(),
                },
            },
        };
    });
}
const setup3id = (threeIdx, keyring) => __awaiter(void 0, void 0, void 0, function* () {
    const genState = keyring.get3idState(true);
    const forcedDID = genState.metadata.controllers[0];
    let didProvider = new did_provider_1.DidProvider({
        permissions: mockedPermissions,
        threeIdx,
        keyring,
        forcedDID,
    });
    yield threeIdx.setDIDProvider(didProvider);
    yield threeIdx.create3idDoc(genState);
    didProvider = new did_provider_1.DidProvider({ permissions: mockedPermissions, threeIdx, keyring });
    yield threeIdx.setDIDProvider(didProvider);
});
const mockedPermissions = {
    request: () => Promise.resolve([]),
    has: () => true,
};
describe('ThreeIDX', () => {
    jest.setTimeout(250000);
    let tmpFolder;
    let ipfs;
    let ceramic;
    let keyring;
    let threeIdx;
    let anchorService;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        tmpFolder = yield tmp_promise_1.default.dir({ unsafeCleanup: true });
        ipfs = yield ipfs_1.default.create(genIpfsConf(tmpFolder.path));
        ceramic = yield core_1.default.create(ipfs, {
            stateStoreDirectory: tmpFolder.path + '/ceramic/',
            anchorOnRequest: false,
        });
        anchorService = ceramic.context.anchorService;
        const did = new dids_1.DID({
            resolver: Object.assign(Object.assign({}, key_did_resolver_2.default.getResolver()), _3id_did_resolver_1.default.getResolver(ceramic)),
        });
        yield ceramic.setDID(did);
        yield idx_tools_1.publishIDXConfig(ceramic);
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        yield ceramic.close();
        yield ipfs.stop();
        yield tmpFolder.cleanup();
    }));
    beforeEach(() => {
        keyring = new keyring_1.default(random_1.randomBytes(32));
        threeIdx = new three_idx_1.ThreeIDX(ceramic);
    });
    it('creates 3id doc', () => __awaiter(void 0, void 0, void 0, function* () {
        keyring = new keyring_1.default(seed);
        yield setup3id(threeIdx, keyring);
        const state = threeIdx.docs.threeId.state;
        delete state.log;
        delete state.metadata.unique;
        expect(state).toMatchSnapshot();
    }));
    it('handles v0 3ID correctly', () => __awaiter(void 0, void 0, void 0, function* () {
        const v03ID = 'did:3:abc234';
        yield setup3id(threeIdx, keyring);
        const v13ID = threeIdx.id;
        threeIdx.setV03ID(v03ID);
        expect(threeIdx.id).not.toEqual(v13ID);
        expect(threeIdx.id).toEqual(v03ID);
    }));
    it('gets correct 3id version', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        expect(threeIdx.get3idVersion()).toEqual('0');
        yield threeIdx.createIDX();
        yield anchorService.anchor();
        yield pauseSeconds(1);
        yield threeIdx.docs.threeId.sync();
        yield threeIdx.docs.threeId.update({ asdf: 123 }, undefined, { anchor: true });
        yield anchorService.anchor();
        yield pauseSeconds(1);
        yield threeIdx.docs.threeId.sync();
        const latestCommit = threeIdx.docs.threeId.commitId.commit;
        expect(threeIdx.get3idVersion()).toEqual(latestCommit.toString());
    }));
    it('creates authMapEntry', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        const newAuthEntry = yield genAuthEntryCreate();
        const update = yield threeIdx.createAuthLinkUpdate(newAuthEntry);
        expect(update.did).toEqual(newAuthEntry.did.id);
        expect(threeIdx.docs[update.did].controllers).toEqual([newAuthEntry.did.id]);
        expect(threeIdx.docs[update.did].content).toEqual({});
        yield threeIdx.applyAuthLinkUpdate(update);
        expect(threeIdx.docs[update.did].content).toEqual({ did: threeIdx.id });
    }));
    it('createIDX with new auth entry', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        const newAuthEntry = yield genAuthEntryCreate();
        yield threeIdx.createIDX(newAuthEntry);
        expect(threeIdx.docs[KEYCHAIN_DEF].content).toEqual({
            authMap: newAuthEntry.mapEntry,
            pastSeeds: [],
        });
        expect(threeIdx.docs.idx.content).toEqual({
            [KEYCHAIN_DEF]: threeIdx.docs[KEYCHAIN_DEF].id.toUrl(),
        });
        expect(threeIdx.docs.idx.metadata.schema).toBe(idx_constants_1.schemas.IdentityIndex);
        expect(threeIdx.docs[KEYCHAIN_DEF].metadata.schema).toBe(idx_constants_1.schemas.ThreeIdKeychain);
        expect(yield it_all_1.default(yield ceramic.pin.ls())).toEqual(expect.arrayContaining([
            threeIdx.docs.threeId.id.toString(),
            threeIdx.docs.idx.id.toString(),
            threeIdx.docs[KEYCHAIN_DEF].id.toString(),
            threeIdx.docs[newAuthEntry.did.id].id.toString(),
        ].map((docid) => docid.replace('ceramic://', '/ceramic/'))));
    }));
    it('createIDX with no auth entry', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        yield threeIdx.createIDX();
        expect(threeIdx.docs.idx.content).toEqual({
            [KEYCHAIN_DEF]: threeIdx.docs[KEYCHAIN_DEF].id.toUrl(),
        });
        expect(threeIdx.docs.idx.metadata.schema).toBe(idx_constants_1.schemas.IdentityIndex);
        expect(threeIdx.docs[KEYCHAIN_DEF].metadata.schema).toBeUndefined();
        expect(yield it_all_1.default(yield ceramic.pin.ls())).toEqual(expect.arrayContaining([threeIdx.docs.threeId.id.toString(), threeIdx.docs.idx.id.toString()].map((docid) => docid.replace('ceramic://', '/ceramic/'))));
    }));
    it('loadIDX fails if authLink does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        const newAuthEntry = yield genAuthEntryCreate();
        expect(yield threeIdx.loadIDX(newAuthEntry.did.id)).toEqual(null);
    }));
    it('loadIDX works if IDX created', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        const newAuthEntry = yield genAuthEntryCreate();
        yield threeIdx.createIDX(newAuthEntry);
        expect(yield threeIdx.loadIDX(newAuthEntry.did.id)).toEqual({
            seed: newAuthEntry.mapEntry[newAuthEntry.did.id].data,
            pastSeeds: [],
        });
    }));
    it('addAuthEntries', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        const [nae1, nae2, nae3] = yield Promise.all([
            genAuthEntryCreate(),
            genAuthEntryCreate(),
            genAuthEntryCreate(),
        ]);
        yield threeIdx.createIDX(nae1);
        expect(threeIdx.getAuthMap()).toEqual(nae1.mapEntry);
        yield threeIdx.addAuthEntries([nae2, nae3]);
        expect(threeIdx.getAuthMap()).toEqual(Object.assign(Object.assign(Object.assign({}, nae1.mapEntry), nae2.mapEntry), nae3.mapEntry));
        expect(yield it_all_1.default(yield ceramic.pin.ls())).toEqual(expect.arrayContaining([
            threeIdx.docs[nae1.did.id].id.toString(),
            threeIdx.docs[nae2.did.id].id.toString(),
            threeIdx.docs[nae3.did.id].id.toString(),
        ]));
    }));
    it('rotateKeys', () => __awaiter(void 0, void 0, void 0, function* () {
        yield setup3id(threeIdx, keyring);
        const [nae1, nae2, nae3] = yield Promise.all([
            genAuthEntryCreate(),
            genAuthEntryCreate(),
            genAuthEntryCreate(),
        ]);
        yield threeIdx.createIDX(nae1);
        yield threeIdx.addAuthEntries([nae2, nae3]);
        yield keyring.generateNewKeys(threeIdx.get3idVersion());
        const new3idState = keyring.get3idState();
        const updatedAuthMap = {
            [nae1.did.id]: { data: fakeJWE(), id: fakeJWE() },
            [nae2.did.id]: { data: fakeJWE(), id: fakeJWE() },
        };
        yield threeIdx.rotateKeys(new3idState, keyring.pastSeeds, updatedAuthMap);
        yield anchorService.anchor();
        yield pauseSeconds(2);
        expect(threeIdx.getAuthMap()).toEqual(updatedAuthMap);
        yield threeIdx.docs.threeId.sync();
        const state = threeIdx.docs.threeId.state;
        expect(state.content).toEqual(expect.objectContaining(new3idState.content));
        expect(state.metadata.controllers).toEqual(new3idState.metadata.controllers);
        expect(yield threeIdx.loadIDX(nae1.did.id)).toEqual({
            seed: updatedAuthMap[nae1.did.id].data,
            pastSeeds: keyring.pastSeeds,
        });
    }));
});
//# sourceMappingURL=three-idx.test.js.map