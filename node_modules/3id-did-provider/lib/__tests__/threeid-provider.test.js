"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const threeid_provider_1 = __importDefault(require("../threeid-provider"));
const random_1 = require("@stablelib/random");
const tmp_promise_1 = __importDefault(require("tmp-promise"));
const core_1 = __importDefault(require("@ceramicnetwork/core"));
const ipfs_1 = __importDefault(require("ipfs"));
const idx_tools_1 = require("@ceramicstudio/idx-tools");
const dag_jose_1 = __importDefault(require("dag-jose"));
const sha2_1 = require("multiformats/hashes/sha2");
const legacy_1 = __importDefault(require("multiformats/legacy"));
const u8a = __importStar(require("uint8arrays"));
const dids_1 = require("dids");
const key_did_resolver_1 = __importDefault(require("key-did-resolver"));
const _3id_did_resolver_1 = __importDefault(require("@ceramicnetwork/3id-did-resolver"));
const seed = u8a.fromString('af0253c646e3d6ccf93758154f55b6055ab5739e22d54fb0b3b6ad1819c73ffaaca52378afeda236f41755c59db9e8aeb30d4cefbd61327603ba6aee63a59b1d', 'base16');
const randomAuthSecret = () => random_1.randomBytes(32);
const getPermissionMock = jest.fn(() => Promise.resolve([]));
const didDocResult = (id) => ({
    didDocument: {
        authentication: [
            {
                controller: id,
                id: id + '#e2Z2Dq3958ZPPWA',
                publicKeyBase58: '25sGY37UkdKKW4irbH9qxdxRUvqYZi5z26J5EqjTSAueS',
                type: 'EcdsaSecp256k1Signature2019',
            },
        ],
        id,
        keyAgreement: [
            {
                controller: id,
                id: id + '#RvxVH2RhN7KTkKk',
                publicKeyBase58: '9iv4ZyqUetpcFe4cQuoRwjhUDc42spkocJJkCuTnkNYz',
                type: 'X25519KeyAgreementKey2019',
            },
        ],
        verificationMethod: [
            {
                controller: id,
                id: id + '#RvxVH2RhN7KTkKk',
                publicKeyBase58: '9iv4ZyqUetpcFe4cQuoRwjhUDc42spkocJJkCuTnkNYz',
                type: 'X25519KeyAgreementKey2019',
            },
            {
                controller: id,
                id: id + '#e2Z2Dq3958ZPPWA',
                publicKeyBase58: '25sGY37UkdKKW4irbH9qxdxRUvqYZi5z26J5EqjTSAueS',
                type: 'EcdsaSecp256k1Signature2019',
            },
        ],
    },
    didDocumentMetadata: { versionId: '0' },
    didResolutionMetadata: { contentType: 'application/did+json' },
});
function genIpfsConf(folder) {
    const hasher = {};
    hasher[sha2_1.sha256.code] = sha2_1.sha256;
    const format = legacy_1.default(dag_jose_1.default, { hashes: hasher });
    return {
        ipld: { formats: [format] },
        repo: `${folder}/ipfs/`,
        config: {
            Addresses: { Swarm: [] },
            Bootstrap: [],
        },
        silent: true,
    };
}
const pauseSeconds = (sec) => new Promise((res) => setTimeout(res, sec * 1000));
jest.mock('cross-fetch', () => {
    return () => ({
        ok: true,
        json: () => ({
            value: {
                publicKey: [
                    {
                        id: 'did:3:GENESIS#signingKey',
                        type: 'Secp256k1VerificationKey2018',
                        publicKeyHex: '0452fbcde75f7ddd7cff18767e2b5536211f500ad474c15da8e74577a573e7a346f2192ef49a5aa0552c41f181a7950af3afdb93cafcbff18156943e3ba312e5b2',
                    },
                    {
                        id: 'did:3:GENESIS#encryptionKey',
                        type: 'Curve25519EncryptionPublicKey',
                        publicKeyBase64: 'DFxR24MNHVxEDAdL2f6pPEwNDJ2p0Ldyjoo7y/ItLDc=',
                    },
                ],
                authentication: [
                    {
                        type: 'Secp256k1SignatureAuthentication2018',
                        publicKey: 'did:3:GENESIS#signingKey',
                    },
                ],
            },
        }),
    });
});
describe('ThreeIdProvider', () => {
    jest.setTimeout(45000);
    let tmpFolder;
    let ipfs;
    let ceramic;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        tmpFolder = yield tmp_promise_1.default.dir({ unsafeCleanup: true });
        ipfs = yield ipfs_1.default.create(genIpfsConf(tmpFolder.path));
        ceramic = yield core_1.default.create(ipfs, {
            stateStoreDirectory: tmpFolder.path + '/ceramic/',
            anchorOnRequest: false,
        });
        const did = new dids_1.DID({
            resolver: Object.assign(Object.assign({}, key_did_resolver_1.default.getResolver()), _3id_did_resolver_1.default.getResolver(ceramic)),
        });
        yield ceramic.setDID(did);
        yield idx_tools_1.publishIDXConfig(ceramic);
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        yield ceramic.close();
        yield ipfs.stop();
        yield tmpFolder.cleanup();
    }));
    describe('.create', () => {
        it('Creates instance from seed', () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const config = {
                getPermission: getPermissionMock,
                seed,
                ceramic,
            };
            const idw = yield threeid_provider_1.default.create(config);
            expect(yield ((_a = ceramic.did) === null || _a === void 0 ? void 0 : _a.resolve(idw.id))).toEqual(didDocResult(idw.id));
            expect(yield idw.keychain.list()).toEqual([]);
        }));
        it('Creates instance from seed and same did with seed + did', () => __awaiter(void 0, void 0, void 0, function* () {
            var _b;
            const config = {
                getPermission: getPermissionMock,
                seed,
                ceramic,
            };
            const idw = yield threeid_provider_1.default.create(config);
            const expectedDidDoc = didDocResult(idw.id);
            const configSeedDid = {
                getPermission: getPermissionMock,
                seed,
                ceramic,
                did: idw.id,
            };
            const idw2 = yield threeid_provider_1.default.create(configSeedDid);
            expect(idw2.id).toEqual(idw.id);
            expect(yield ((_b = ceramic.did) === null || _b === void 0 ? void 0 : _b.resolve(idw2.id))).toEqual(expectedDidDoc);
        }));
        it('Creates instance from authSecret, new DID', () => __awaiter(void 0, void 0, void 0, function* () {
            var _c;
            const config = {
                getPermission: getPermissionMock,
                authSecret: randomAuthSecret(),
                authId: 'testAuth',
                ceramic,
            };
            const idw = yield threeid_provider_1.default.create(config);
            expect(yield ((_c = ceramic.did) === null || _c === void 0 ? void 0 : _c.resolve(idw.id))).toBeDefined();
            expect(yield idw.keychain.list()).toEqual(['testAuth']);
        }));
        it('Creates instance from authSecret, existing DID', () => __awaiter(void 0, void 0, void 0, function* () {
            var _d;
            const config = {
                getPermission: getPermissionMock,
                authSecret: randomAuthSecret(),
                authId: 'testAuth',
                ceramic,
            };
            const idw1 = yield threeid_provider_1.default.create(config);
            expect(yield ((_d = ceramic.did) === null || _d === void 0 ? void 0 : _d.resolve(idw1.id))).toBeDefined();
            expect(yield idw1.keychain.list()).toEqual(['testAuth']);
            const idw2 = yield threeid_provider_1.default.create(config);
            expect(yield idw2.keychain.list()).toEqual(['testAuth']);
            expect(idw1.id).toEqual(idw2.id);
        }));
        it('Create instance with seed & v03ID', () => __awaiter(void 0, void 0, void 0, function* () {
            var _e;
            const v03ID = 'did:3:bafyreidv6yl2bbmuslkqby45hdn6sd6ha22zlolxjjxxz4suuwfqpezewu';
            const config = {
                getPermission: getPermissionMock,
                seed,
                v03ID,
                ceramic,
            };
            const idw = yield threeid_provider_1.default.create(config);
            expect(idw.id).toEqual(v03ID);
            expect(yield ((_e = ceramic.did) === null || _e === void 0 ? void 0 : _e.resolve(idw.id))).toMatchSnapshot();
            expect(yield idw.keychain.list()).toEqual([]);
        }));
    });
    describe('.keychain', () => {
        it('Adds authSecret to the keychain', () => __awaiter(void 0, void 0, void 0, function* () {
            const config1 = { getPermission: getPermissionMock, seed, ceramic };
            const idw1 = yield threeid_provider_1.default.create(config1);
            expect(yield idw1.keychain.list()).toEqual([]);
            yield idw1.keychain.add('auth2', randomAuthSecret());
            yield idw1.keychain.commit();
            expect(yield idw1.keychain.list()).toEqual(['auth2']);
        }));
        it('Creates instance from added authSecret', () => __awaiter(void 0, void 0, void 0, function* () {
            const config1 = { getPermission: getPermissionMock, seed: random_1.randomBytes(32), ceramic };
            const idw1 = yield threeid_provider_1.default.create(config1);
            expect(yield idw1.keychain.list()).toEqual([]);
            const config2 = {
                getPermission: getPermissionMock,
                authId: 'auth2',
                authSecret: randomAuthSecret(),
                ceramic,
            };
            yield idw1.keychain.add(config2.authId, config2.authSecret);
            yield idw1.keychain.commit();
            const idw2 = yield threeid_provider_1.default.create(config2);
            expect(yield idw2.keychain.list()).toEqual(['auth2']);
            expect(idw1.id).toEqual(idw2.id);
        }));
        it('Removes authSecret from keychain and creates instance', () => __awaiter(void 0, void 0, void 0, function* () {
            const config1 = {
                getPermission: getPermissionMock,
                authSecret: randomAuthSecret(),
                authId: 'auth1',
                ceramic,
            };
            const idw1 = yield threeid_provider_1.default.create(config1);
            expect(yield idw1.keychain.list()).toEqual(['auth1']);
            const config2 = {
                getPermission: getPermissionMock,
                authId: 'auth2',
                authSecret: randomAuthSecret(),
                ceramic,
            };
            yield idw1.keychain.add(config2.authId, config2.authSecret);
            yield pauseSeconds(2);
            yield idw1.keychain.commit();
            expect(yield idw1.keychain.list()).toEqual(['auth1', 'auth2']);
            yield idw1.keychain.remove('auth1');
            yield pauseSeconds(2);
            yield idw1.keychain.commit();
            expect(yield idw1.keychain.list()).toEqual(['auth2']);
            const idw2 = yield threeid_provider_1.default.create(config2);
            expect(idw1.id).toEqual(idw2.id);
            yield expect(threeid_provider_1.default.create(config1)).rejects.toThrow('Unable to find auth data');
        }));
        it('Does keyrotation when v03ID is being used', () => __awaiter(void 0, void 0, void 0, function* () {
            const v03ID = 'did:3:bafyreiffkeeq4wq2htejqla2is5ognligi4lvjhwrpqpl2kazjdoecmugi';
            const config = {
                getPermission: getPermissionMock,
                seed,
                v03ID,
                ceramic,
            };
            const idw1 = yield threeid_provider_1.default.create(config);
            const config1 = {
                getPermission: getPermissionMock,
                authId: 'auth1',
                authSecret: randomAuthSecret(),
                ceramic,
            };
            const config2 = {
                getPermission: getPermissionMock,
                authId: 'auth2',
                authSecret: randomAuthSecret(),
                ceramic,
            };
            yield idw1.keychain.add(config1.authId, config1.authSecret);
            yield idw1.keychain.add(config2.authId, config2.authSecret);
            yield pauseSeconds(2);
            yield idw1.keychain.commit();
            expect(yield idw1.keychain.list()).toEqual(['auth2', 'auth1']);
            yield idw1.keychain.remove('auth1');
            yield pauseSeconds(2);
            yield idw1.keychain.commit();
            expect(yield idw1.keychain.list()).toEqual(['auth2']);
            const idw2 = yield threeid_provider_1.default.create(config2);
            expect(idw1.id).toEqual(idw2.id);
            yield expect(threeid_provider_1.default.create(config1)).rejects.toThrow('Unable to find auth data');
        }));
    });
});
describe('ThreeIdProvider with disabled IDX', () => {
    let tmpFolder;
    let ipfs;
    let ceramic;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        tmpFolder = yield tmp_promise_1.default.dir({ unsafeCleanup: true });
        ipfs = yield ipfs_1.default.create(genIpfsConf(tmpFolder.path));
        ceramic = yield core_1.default.create(ipfs, { stateStoreDirectory: tmpFolder.path + '/ceramic/' });
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        yield ceramic.close();
        yield ipfs.stop();
        yield tmpFolder.cleanup();
    }));
    describe('.create', () => {
        it('Creates instance from seed', () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const config = {
                getPermission: getPermissionMock,
                seed,
                ceramic,
                disableIDX: true,
            };
            const idw = yield threeid_provider_1.default.create(config);
            expect(yield ((_a = ceramic.did) === null || _a === void 0 ? void 0 : _a.resolve(idw.id))).toBeDefined();
            expect(yield idw.keychain.list()).toEqual([]);
            expect(idw._threeIdx.docs.idx).toBeUndefined();
        }));
        it('Throws when trying to creates instance from authSecret', () => __awaiter(void 0, void 0, void 0, function* () {
            const config = {
                getPermission: getPermissionMock,
                authSecret: randomAuthSecret(),
                authId: 'testAuth',
                ceramic,
                disableIDX: true,
            };
            yield expect(threeid_provider_1.default.create(config)).rejects.toThrow('AuthId cannot be used with disableIDX');
        }));
    });
});
//# sourceMappingURL=threeid-provider.test.js.map