"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const did_provider_1 = require("../did-provider");
const did_jwt_1 = require("did-jwt");
const dag_jose_utils_1 = require("dag-jose-utils");
const keyring_1 = __importDefault(require("../keyring"));
const u8a = __importStar(require("uint8arrays"));
describe('DidProvider', () => {
    let nextId = 0;
    function expectRPC(provider, origin, req, res) {
        const id = nextId++;
        return expect(provider.send(Object.assign({ jsonrpc: '2.0', id }, req), origin)).resolves.toEqual(Object.assign({ jsonrpc: '2.0', id }, res));
    }
    test('has a `isDidProvider` prop', () => {
        const provider = new did_provider_1.DidProvider({});
        expect(provider.isDidProvider).toBe(true);
    });
    test('`did_authenticate` method returns the accounts', () => __awaiter(void 0, void 0, void 0, function* () {
        global.Date.now = jest.fn(() => 1606236374000);
        const config = {
            permissions: {
                request: jest.fn((origin, paths) => Promise.resolve(paths)),
            },
            threeIdx: {
                id: 'did:3:test',
                get3idVersion: jest.fn(() => '0'),
            },
            keyring: {
                getSigner: () => () => Promise.resolve('signed'),
                getMgmtSigner: () => () => Promise.resolve('signed'),
                getKeyFragment: jest.fn(() => 'ab832'),
            },
        };
        const nonce = 'asdf';
        const aud = 'foo';
        yield expectRPC(new did_provider_1.DidProvider(config), 'foo', { method: 'did_authenticate', params: { paths: [] } }, {
            result: {
                payload: 'eyJkaWQiOiJkaWQ6Mzp0ZXN0IiwiZXhwIjoxNjA2MjM2OTc0LCJwYXRocyI6W119',
                signatures: [
                    {
                        protected: 'eyJraWQiOiJkaWQ6Mzp0ZXN0P3ZlcnNpb24taWQ9MCNhYjgzMiIsImFsZyI6IkVTMjU2SyJ9',
                        signature: 'signed',
                    },
                ],
            },
        });
        expect(config.permissions.request).toBeCalledWith('foo', []);
        yield expectRPC(new did_provider_1.DidProvider(config), 'foo', { method: 'did_authenticate', params: { paths: ['/1'], nonce, aud } }, {
            result: {
                payload: 'eyJhdWQiOiJmb28iLCJkaWQiOiJkaWQ6Mzp0ZXN0IiwiZXhwIjoxNjA2MjM2OTc0LCJub25jZSI6ImFzZGYiLCJwYXRocyI6WyIvMSJdfQ',
                signatures: [
                    {
                        protected: 'eyJraWQiOiJkaWQ6Mzp0ZXN0P3ZlcnNpb24taWQ9MCNhYjgzMiIsImFsZyI6IkVTMjU2SyJ9',
                        signature: 'signed',
                    },
                ],
            },
        });
    }));
    test('`did_createJWS` method throws an error if the user is not authenticated', () => __awaiter(void 0, void 0, void 0, function* () {
        const payload = { foo: 'bar' };
        const protectedHeader = { bar: 'baz' };
        const permissions = { has: jest.fn(() => false) };
        yield expectRPC(new did_provider_1.DidProvider({ permissions }), 'bar', { method: 'did_createJWS', params: { payload, protected: protectedHeader } }, { error: { code: 4100, message: 'Unauthorized' } });
        expect(permissions.has).toBeCalledWith('bar');
    }));
    test('`did_createJWS` returns the general JWS', () => __awaiter(void 0, void 0, void 0, function* () {
        const config = {
            permissions: { has: jest.fn(() => true) },
            threeIdx: {
                id: 'did:3:asdf',
                get3idVersion: jest.fn(() => '0'),
            },
            keyring: {
                getSigner: () => () => Promise.resolve('signed'),
                getMgmtSigner: () => () => Promise.resolve('signed'),
                getKeyFragment: jest.fn(() => 'ab832'),
            },
        };
        const payload = { foo: 'bar' };
        const protectedHeader = { bar: 'baz' };
        let did = 'did:3:asdf';
        yield expectRPC(new did_provider_1.DidProvider(config), null, { method: 'did_createJWS', params: { payload, protected: protectedHeader, did } }, {
            result: {
                jws: {
                    payload: 'eyJmb28iOiJiYXIifQ',
                    signatures: [
                        {
                            protected: 'eyJiYXIiOiJiYXoiLCJraWQiOiJkaWQ6Mzphc2RmP3ZlcnNpb24taWQ9MCNhYjgzMiIsImFsZyI6IkVTMjU2SyJ9',
                            signature: 'signed',
                        },
                    ],
                },
            },
        });
        yield expectRPC(new did_provider_1.DidProvider(config), null, {
            method: 'did_createJWS',
            params: { payload, protected: protectedHeader, did, revocable: true },
        }, {
            result: {
                jws: {
                    payload: 'eyJmb28iOiJiYXIifQ',
                    signatures: [
                        {
                            protected: 'eyJiYXIiOiJiYXoiLCJraWQiOiJkaWQ6Mzphc2RmI2FiODMyIiwiYWxnIjoiRVMyNTZLIn0',
                            signature: 'signed',
                        },
                    ],
                },
            },
        });
        did = 'did:key:fewfq';
        yield expectRPC(new did_provider_1.DidProvider(config), null, { method: 'did_createJWS', params: { payload, protected: protectedHeader, did } }, {
            result: {
                jws: {
                    payload: 'eyJmb28iOiJiYXIifQ',
                    signatures: [
                        {
                            protected: 'eyJiYXIiOiJiYXoiLCJraWQiOiJkaWQ6a2V5OmZld2ZxI2Zld2ZxIiwiYWxnIjoiRVMyNTZLIn0',
                            signature: 'signed',
                        },
                    ],
                },
            },
        });
    }));
    test('`did_decryptJWE` correctly decrypts a JWE', () => __awaiter(void 0, void 0, void 0, function* () {
        const keyring = new keyring_1.default(u8a.fromString('f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b', 'base16'));
        const encrypter = did_jwt_1.x25519Encrypter(keyring.getEncryptionPublicKey());
        const cleartext = dag_jose_utils_1.prepareCleartext({ asdf: 234 });
        const jwe = yield did_jwt_1.createJWE(cleartext, [encrypter]);
        const config = {
            permissions: { has: jest.fn(() => true) },
            keyring,
        };
        yield expectRPC(new did_provider_1.DidProvider(config), null, { method: 'did_decryptJWE', params: { jwe } }, { result: { cleartext: u8a.toString(cleartext, 'base64pad') } });
    }));
    test('`did_decryptJWE` correctly respects permissions', () => __awaiter(void 0, void 0, void 0, function* () {
        const keyring = new keyring_1.default(u8a.fromString('f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b', 'base16'));
        const encrypter = did_jwt_1.x25519Encrypter(keyring.getEncryptionPublicKey());
        const cleartext1 = dag_jose_utils_1.prepareCleartext({ paths: ['a'] });
        const cleartext2 = dag_jose_utils_1.prepareCleartext({ paths: ['b'] });
        const jwe1 = yield did_jwt_1.createJWE(cleartext1, [encrypter]);
        const jwe2 = yield did_jwt_1.createJWE(cleartext2, [encrypter]);
        const config = {
            permissions: {
                has: jest.fn((_, paths) => {
                    return paths ? paths.includes('a') : true;
                }),
            },
            keyring,
        };
        yield expectRPC(new did_provider_1.DidProvider(config), null, { method: 'did_decryptJWE', params: { jwe: jwe1 } }, { result: { cleartext: u8a.toString(cleartext1, 'base64pad') } });
        yield expectRPC(new did_provider_1.DidProvider(config), null, { method: 'did_decryptJWE', params: { jwe: jwe2 } }, { error: { code: 4100, data: undefined, message: 'Unauthorized' } });
    }));
});
//# sourceMappingURL=did-provider.test.js.map