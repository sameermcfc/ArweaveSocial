"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LATEST = void 0;
const x25519_1 = require("@stablelib/x25519");
const hdnode_1 = require("@ethersproject/hdnode");
const did_jwt_1 = require("did-jwt");
const random_1 = require("@stablelib/random");
const dag_jose_utils_1 = require("dag-jose-utils");
const utils_1 = require("./utils");
exports.LATEST = 'latest';
const GENESIS = 'genesis';
const BASE_PATH = "m/51073068'";
const LEGACY_BASE_PATH = "m/7696500'/0'/0'";
function deriveKeySet(seed, v03ID) {
    const seedNode = hdnode_1.HDNode.fromSeed(seed);
    let hdNode;
    if (v03ID) {
        hdNode = seedNode.derivePath(LEGACY_BASE_PATH);
    }
    else {
        hdNode = seedNode.derivePath(BASE_PATH);
    }
    const signing = hdNode.derivePath('0');
    const management = v03ID ? signing : hdNode.derivePath('1');
    const encryption = x25519_1.generateKeyPairFromSeed(utils_1.hexToU8A(hdNode.derivePath('2').privateKey.slice(2)));
    return {
        seed,
        publicKeys: {
            signing: utils_1.hexToU8A(signing.publicKey.slice(2)),
            management: utils_1.hexToU8A(management.publicKey.slice(2)),
            encryption: encryption.publicKey,
        },
        secretKeys: {
            signing: utils_1.hexToU8A(signing.privateKey.slice(2)),
            management: utils_1.hexToU8A(management.privateKey.slice(2)),
            encryption: encryption.secretKey,
        },
        v03ID,
    };
}
class Keyring {
    constructor(seed, v03ID) {
        this._keySets = {};
        this._versionMap = {};
        this._pastSeeds = [];
        if (!seed) {
            seed = random_1.randomBytes(32);
        }
        if (v03ID)
            this._v03ID = v03ID;
        this._versionMap[GENESIS] = exports.LATEST;
        this._keySets[exports.LATEST] = deriveKeySet(seed, v03ID);
        let encKid = utils_1.encodeKey(this._keySets[exports.LATEST].publicKeys.encryption, 'x25519').slice(-15);
        this._versionMap[encKid] = exports.LATEST;
        encKid = utils_1.encodeKey(this._keySets[exports.LATEST].publicKeys.management, 'secp256k1');
        this._versionMap[encKid] = exports.LATEST;
    }
    get v03ID() {
        return this._v03ID;
    }
    get seed() {
        return this._keySets[exports.LATEST].seed;
    }
    get pastSeeds() {
        return this._pastSeeds;
    }
    loadPastSeeds(pastSeeds) {
        return __awaiter(this, void 0, void 0, function* () {
            this._pastSeeds = [...pastSeeds];
            let version = exports.LATEST;
            let jwe = pastSeeds.pop();
            while (jwe) {
                const decrypted = yield this.asymDecryptJWE(jwe, [], version);
                version = Object.keys(decrypted).find((k) => k !== 'v03ID');
                if (decrypted.v03ID) {
                    this._v03ID = decrypted.v03ID;
                    delete decrypted.v03ID;
                    this._versionMap[GENESIS] = version;
                }
                this._keySets[version] = deriveKeySet(new Uint8Array(decrypted[version]), this._v03ID);
                this._updateVersionMap(version, this._keySets[version]);
                jwe = pastSeeds.pop();
            }
        });
    }
    _updateVersionMap(version, keySet) {
        let encKid = utils_1.encodeKey(keySet.publicKeys.encryption, 'x25519').slice(-15);
        this._versionMap[encKid] = version;
        encKid = utils_1.encodeKey(keySet.publicKeys.management, 'secp256k1');
        this._versionMap[encKid] = version;
    }
    generateNewKeys(prevVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._keySets[prevVersion])
                throw new Error('Key set version already exist');
            this._updateVersionMap(prevVersion, this._keySets[exports.LATEST]);
            this._keySets[prevVersion] = this._keySets[exports.LATEST];
            this._keySets[exports.LATEST] = deriveKeySet(random_1.randomBytes(32));
            this._updateVersionMap(exports.LATEST, this._keySets[exports.LATEST]);
            const cleartext = { [prevVersion]: this._keySets[prevVersion].seed };
            if (this._keySets[prevVersion].v03ID)
                cleartext.v03ID = this._keySets[prevVersion].v03ID;
            this._pastSeeds.push(yield this.asymEncryptJWE(cleartext));
        });
    }
    getAsymDecrypter(fragments = [], version) {
        if (!version) {
            const fragmentWithKey = fragments.find((fragment) => this._versionMap[fragment]);
            version = fragmentWithKey ? this._versionMap[fragmentWithKey] : exports.LATEST;
        }
        const key = this._keySets[version].secretKeys.encryption;
        return did_jwt_1.x25519Decrypter(key);
    }
    asymDecryptJWE(jwe, kids, version) {
        return __awaiter(this, void 0, void 0, function* () {
            return dag_jose_utils_1.decodeCleartext(yield did_jwt_1.decryptJWE(jwe, this.getAsymDecrypter(kids, version)));
        });
    }
    asymEncryptJWE(cleartext, kid) {
        return __awaiter(this, void 0, void 0, function* () {
            const encrypter = did_jwt_1.x25519Encrypter(this.getEncryptionPublicKey(), kid);
            return did_jwt_1.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), [encrypter]);
        });
    }
    getSigner(version = exports.LATEST) {
        const keyset = this._keySets[version] || this._keySets[exports.LATEST];
        return did_jwt_1.EllipticSigner(utils_1.u8aToHex(keyset.secretKeys.signing));
    }
    getKeyFragment(version = exports.LATEST, encKey = false) {
        const keyset = this._keySets[version] || this._keySets[exports.LATEST];
        if (encKey) {
            return utils_1.encodeKey(keyset.publicKeys.encryption, 'x25519').slice(-15);
        }
        return utils_1.encodeKey(keyset.publicKeys.signing, 'secp256k1').slice(-15);
    }
    getMgmtSigner(pubKey) {
        const keyset = this._keySets[this._versionMap[pubKey]].secretKeys;
        if (!keyset)
            throw new Error(`Key not found: ${pubKey}`);
        return did_jwt_1.EllipticSigner(utils_1.u8aToHex(keyset.management));
    }
    getEncryptionPublicKey() {
        return this._keySets[exports.LATEST].publicKeys.encryption;
    }
    get3idState(genesis) {
        const keyVer = genesis ? this._versionMap[GENESIS] : exports.LATEST;
        const keys = this._keySets[keyVer].publicKeys;
        const signing = utils_1.encodeKey(keys.signing, 'secp256k1');
        const encryption = utils_1.encodeKey(keys.encryption, 'x25519');
        const state = {
            metadata: { controllers: [`did:key:${utils_1.encodeKey(keys.management, 'secp256k1')}`] },
            content: {
                publicKeys: {
                    [signing.slice(-15)]: signing,
                    [encryption.slice(-15)]: encryption,
                },
            },
        };
        if (genesis) {
            state.metadata.family = '3id';
        }
        if (this._keySets[keyVer].v03ID) {
            state.metadata.deterministic = true;
            delete state.content;
        }
        return state;
    }
}
exports.default = Keyring;
//# sourceMappingURL=keyring.js.map