"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DidProvider = exports.didMethods = void 0;
const dag_jose_utils_1 = require("dag-jose-utils");
const did_jwt_1 = require("did-jwt");
const rpc_utils_1 = require("rpc-utils");
const utils_1 = require("./utils");
function toGeneralJWS(jws) {
    const [protectedHeader, payload, signature] = jws.split('.');
    return {
        payload,
        signatures: [{ protected: protectedHeader, signature }],
    };
}
function sign(payload, didWithFragment, keyring, threeIdx, protectedHeader = {}, revocable) {
    return __awaiter(this, void 0, void 0, function* () {
        let [did, keyFragment] = didWithFragment.split('#');
        let kid, signer;
        if (did.startsWith('did:key:')) {
            const pubkey = did.split(':')[2];
            kid = `${did}#${pubkey}`;
            signer = keyring.getMgmtSigner(pubkey);
        }
        else {
            if (did !== threeIdx.id)
                throw new Error(`Unknown DID: ${did}`);
            const version = threeIdx.get3idVersion();
            if (!keyFragment)
                keyFragment = keyring.getKeyFragment(version);
            kid = `${did}${revocable ? '' : `?version-id=${version}`}#${keyFragment}`;
            signer = keyring.getSigner(version);
        }
        const header = utils_1.toStableObject(Object.assign(protectedHeader, { kid }));
        const jws = yield did_jwt_1.createJWS(utils_1.toStableObject(payload), signer, header);
        return toGeneralJWS(jws);
    });
}
exports.didMethods = {
    did_authenticate: ({ permissions, keyring, threeIdx, origin, forcedDID }, params) => __awaiter(void 0, void 0, void 0, function* () {
        const paths = yield permissions.request(origin, params.paths || []);
        if (paths === null)
            throw new rpc_utils_1.RPCError(4001, 'User Rejected Request');
        return sign({
            did: forcedDID || threeIdx.id,
            aud: params.aud,
            nonce: params.nonce,
            paths,
            exp: Math.floor(Date.now() / 1000) + 600,
        }, forcedDID || threeIdx.id, keyring, threeIdx);
    }),
    did_createJWS: ({ permissions, keyring, threeIdx, origin }, params) => __awaiter(void 0, void 0, void 0, function* () {
        if (!permissions.has(origin))
            throw new rpc_utils_1.RPCError(4100, 'Unauthorized');
        const jws = yield sign(params.payload, params.did, keyring, threeIdx, params.protected, params.revocable);
        return { jws };
    }),
    did_decryptJWE: ({ permissions, keyring, origin }, params) => __awaiter(void 0, void 0, void 0, function* () {
        if (!permissions.has(origin))
            throw new rpc_utils_1.RPCError(4100, 'Unauthorized');
        const parsedKids = utils_1.parseJWEKids(params.jwe);
        const decrypter = keyring.getAsymDecrypter(parsedKids);
        const bytes = yield did_jwt_1.decryptJWE(params.jwe, decrypter);
        let obj;
        try {
            obj = dag_jose_utils_1.decodeCleartext(bytes);
        }
        catch (e) {
        }
        if (obj && !permissions.has(origin, obj.paths))
            throw new rpc_utils_1.RPCError(4100, 'Unauthorized');
        return { cleartext: utils_1.encodeBase64(bytes) };
    }),
};
class DidProvider {
    constructor({ permissions, threeIdx, keyring, forcedOrigin, forcedDID }) {
        const handler = rpc_utils_1.createHandler(exports.didMethods);
        this._handle = (origin, msg) => __awaiter(this, void 0, void 0, function* () {
            return yield handler({
                origin: forcedOrigin !== null && forcedOrigin !== void 0 ? forcedOrigin : origin,
                permissions,
                threeIdx,
                keyring,
                forcedDID,
            }, msg);
        });
    }
    get isDidProvider() {
        return true;
    }
    send(msg, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._handle(origin !== null && origin !== void 0 ? origin : '', msg);
        });
    }
}
exports.DidProvider = DidProvider;
//# sourceMappingURL=did-provider.js.map