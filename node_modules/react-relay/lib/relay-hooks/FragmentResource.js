/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var LRUCache = require('./LRUCache');

var invariant = require('invariant');

var _require = require('relay-runtime'),
    getFragmentIdentifier = _require.getFragmentIdentifier,
    getPendingOperationsForFragment = _require.getPendingOperationsForFragment,
    getSelector = _require.getSelector,
    isPromise = _require.isPromise,
    recycleNodesInto = _require.recycleNodesInto,
    reportMissingRequiredFields = _require.reportMissingRequiredFields;

var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
// TODO: Fix to not rely on LRU. If the number of active fragments exceeds this
// capacity, readSpec() will fail to find cached entries and break object
// identity even if data hasn't changed.
var CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array

var CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);

function isMissingData(snapshot) {
  if (Array.isArray(snapshot)) {
    return snapshot.some(function (s) {
      return s.isMissingData;
    });
  }

  return snapshot.isMissingData;
}

function getFragmentResult(cacheKey, snapshot, storeEpoch) {
  if (Array.isArray(snapshot)) {
    return {
      cacheKey: cacheKey,
      snapshot: snapshot,
      data: snapshot.map(function (s) {
        return s.data;
      }),
      isMissingData: isMissingData(snapshot),
      storeEpoch: storeEpoch
    };
  }

  return {
    cacheKey: cacheKey,
    snapshot: snapshot,
    data: snapshot.data,
    isMissingData: isMissingData(snapshot),
    storeEpoch: storeEpoch
  };
}

var FragmentResourceImpl = /*#__PURE__*/function () {
  function FragmentResourceImpl(environment) {
    this._environment = environment;
    this._cache = LRUCache.create(CACHE_CAPACITY);
  }
  /**
   * This function should be called during a Component's render function,
   * to read the data for a fragment, or suspend if the fragment is being
   * fetched.
   */


  var _proto = FragmentResourceImpl.prototype;

  _proto.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {
    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);
  }
  /**
   * Like `read`, but with a pre-computed fragmentIdentifier that should be
   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the
   * arguments.
   */
  ;

  _proto.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {
    var _fragmentNode$metadat;

    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.
    // This is a convenience when consuming fragments via a HOC API, when the
    // prop corresponding to the fragment ref might be passed as null.

    if (fragmentRef == null) {
      return {
        cacheKey: fragmentIdentifier,
        data: null,
        isMissingData: false,
        snapshot: null,
        storeEpoch: 0
      };
    }

    var storeEpoch = environment.getStore().getEpoch(); // If fragmentRef is plural, ensure that it is an array.
    // If it's empty, return the empty array directly before doing any more work.

    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {
      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;

      if (fragmentRef.length === 0) {
        return {
          cacheKey: fragmentIdentifier,
          data: CONSTANT_READONLY_EMPTY_ARRAY,
          isMissingData: false,
          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,
          storeEpoch: storeEpoch
        };
      }
    } // Now we actually attempt to read the fragment:
    // 1. Check if there's a cached value for this fragment


    var cachedValue = this._cache.get(fragmentIdentifier);

    if (cachedValue != null) {
      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {
        environment.__log({
          name: 'suspense.fragment',
          data: cachedValue.result.data,
          fragment: fragmentNode,
          isRelayHooks: true,
          isMissingData: cachedValue.result.isMissingData,
          isPromiseCached: true,
          pendingOperations: cachedValue.pendingOperations
        });

        throw cachedValue.promise;
      }

      if (cachedValue.kind === 'done' && cachedValue.result.snapshot) {
        this._reportMissingRequiredFieldsInSnapshot(cachedValue.result.snapshot);

        return cachedValue.result;
      }
    } // 2. If not, try reading the fragment from the Relay store.
    // If the snapshot has data, return it and save it in cache


    var fragmentSelector = getSelector(fragmentNode, fragmentRef);
    !(fragmentSelector != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : "the `".concat(fragmentKey, "`"), componentDisplayName) : invariant(false) : void 0;
    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {
      return environment.lookup(s);
    }) : environment.lookup(fragmentSelector);
    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);

    if (!fragmentResult.isMissingData) {
      this._reportMissingRequiredFieldsInSnapshot(snapshot);

      this._cache.set(fragmentIdentifier, {
        kind: 'done',
        result: fragmentResult
      });

      return fragmentResult;
    } // 3. If we don't have data in the store, check if a request is in
    // flight for the fragment's parent query, or for another operation
    // that may affect the parent's query data, such as a mutation
    // or subscription. If a promise exists, cache the promise and use it
    // to suspend.


    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;

    var networkPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);

    if (networkPromiseResult != null && isPromise(networkPromiseResult.promise)) {
      environment.__log({
        name: 'suspense.fragment',
        data: fragmentResult.data,
        fragment: fragmentNode,
        isRelayHooks: true,
        isPromiseCached: false,
        isMissingData: fragmentResult.isMissingData,
        pendingOperations: networkPromiseResult.pendingOperations
      });

      throw networkPromiseResult.promise;
    }

    this._reportMissingRequiredFieldsInSnapshot(snapshot);

    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);
  };

  _proto._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {
    var _this = this;

    if (Array.isArray(snapshot)) {
      snapshot.forEach(function (s) {
        if (s.missingRequiredFields != null) {
          reportMissingRequiredFields(_this._environment, s.missingRequiredFields);
        }
      });
    } else {
      if (snapshot.missingRequiredFields != null) {
        reportMissingRequiredFields(this._environment, snapshot.missingRequiredFields);
      }
    }
  };

  _proto.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {
    var result = {};

    for (var _key in fragmentNodes) {
      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);
    }

    return result;
  };

  _proto.subscribe = function subscribe(fragmentResult, callback) {
    var _this2 = this;

    var environment = this._environment;
    var cacheKey = fragmentResult.cacheKey;
    var renderedSnapshot = fragmentResult.snapshot;

    if (!renderedSnapshot) {
      return {
        dispose: function dispose() {}
      };
    } // 1. Check for any updates missed during render phase
    // TODO(T44066760): More efficiently detect if we missed an update


    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),
        didMissUpdates = _this$checkMissedUpda[0],
        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with
    // the latest data.


    if (didMissUpdates) {
      callback();
    } // 3. Establish subscriptions on the snapshot(s)


    var dataSubscriptions = [];

    if (Array.isArray(renderedSnapshot)) {
      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + "If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
      currentSnapshot.forEach(function (snapshot, idx) {
        dataSubscriptions.push(environment.subscribe(snapshot, function (latestSnapshot) {
          var storeEpoch = environment.getStore().getEpoch();

          _this2._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);

          callback();
        }));
      });
    } else {
      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + "If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
      dataSubscriptions.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {
        var storeEpoch = environment.getStore().getEpoch();

        _this2._cache.set(cacheKey, {
          kind: 'done',
          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)
        });

        callback();
      }));
    }

    return {
      dispose: function dispose() {
        dataSubscriptions.map(function (s) {
          return s.dispose();
        });

        _this2._cache["delete"](cacheKey);
      }
    };
  };

  _proto.subscribeSpec = function subscribeSpec(fragmentResults, callback) {
    var _this3 = this;

    var disposables = Object.keys(fragmentResults).map(function (key) {
      return _this3.subscribe(fragmentResults[key], callback);
    });
    return {
      dispose: function dispose() {
        disposables.forEach(function (disposable) {
          disposable.dispose();
        });
      }
    };
  };

  _proto.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {
    var environment = this._environment;
    var renderedSnapshot = fragmentResult.snapshot;

    if (!renderedSnapshot) {
      return [false, null];
    }

    var storeEpoch = null; // Bail out if the store hasn't been written since last read

    storeEpoch = environment.getStore().getEpoch();

    if (fragmentResult.storeEpoch === storeEpoch) {
      return [false, fragmentResult.snapshot];
    }

    var cacheKey = fragmentResult.cacheKey;

    if (Array.isArray(renderedSnapshot)) {
      var didMissUpdates = false;
      var currentSnapshots = [];
      renderedSnapshot.forEach(function (snapshot, idx) {
        var currentSnapshot = environment.lookup(snapshot.selector);
        var renderData = snapshot.data;
        var currentData = currentSnapshot.data;
        var updatedData = recycleNodesInto(renderData, currentData);

        if (updatedData !== renderData) {
          currentSnapshot = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, currentSnapshot), {}, {
            data: updatedData
          });
          didMissUpdates = true;
        }

        currentSnapshots[idx] = currentSnapshot;
      }); // Only update the cache when the data is changed to avoid
      // returning different `data` instances

      if (didMissUpdates) {
        this._cache.set(cacheKey, {
          kind: 'done',
          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)
        });
      }

      return [didMissUpdates, currentSnapshots];
    }

    var currentSnapshot = environment.lookup(renderedSnapshot.selector);
    var renderData = renderedSnapshot.data;
    var currentData = currentSnapshot.data;
    var updatedData = recycleNodesInto(renderData, currentData);
    var updatedCurrentSnapshot = {
      data: updatedData,
      isMissingData: currentSnapshot.isMissingData,
      seenRecords: currentSnapshot.seenRecords,
      selector: currentSnapshot.selector,
      missingRequiredFields: currentSnapshot.missingRequiredFields
    };

    if (updatedData !== renderData) {
      this._cache.set(cacheKey, {
        kind: 'done',
        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)
      });
    }

    return [updatedData !== renderData, updatedCurrentSnapshot];
  };

  _proto.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {
    var _this4 = this;

    return Object.keys(fragmentResults).some(function (key) {
      return _this4.checkMissedUpdates(fragmentResults[key])[0];
    });
  };

  _proto._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {
    var _this5 = this;

    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);

    if (pendingOperationsResult == null) {
      return null;
    } // When the Promise for the request resolves, we need to make sure to
    // update the cache with the latest data available in the store before
    // resolving the Promise


    var networkPromise = pendingOperationsResult.promise;
    var pendingOperations = pendingOperationsResult.pendingOperations;
    var promise = networkPromise.then(function () {
      _this5._cache["delete"](cacheKey);
    })["catch"](function (error) {
      _this5._cache["delete"](cacheKey);
    }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.

    promise.displayName = networkPromise.displayName;

    this._cache.set(cacheKey, {
      kind: 'pending',
      pendingOperations: pendingOperations,
      promise: promise,
      result: fragmentResult
    });

    return {
      promise: promise,
      pendingOperations: pendingOperations
    };
  };

  _proto._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {
    var _currentFragmentResul;

    var currentFragmentResult = this._cache.get(cacheKey);

    if (isPromise(currentFragmentResult)) {
      reportInvalidCachedData(latestSnapshot.selector.node.name);
      return;
    }

    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;

    if (currentSnapshot && !Array.isArray(currentSnapshot)) {
      reportInvalidCachedData(latestSnapshot.selector.node.name);
      return;
    }

    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2["default"])(currentSnapshot) : (0, _toConsumableArray2["default"])(baseSnapshots);
    nextSnapshots[idx] = latestSnapshot;

    this._cache.set(cacheKey, {
      kind: 'done',
      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)
    });
  };

  return FragmentResourceImpl;
}();

function reportInvalidCachedData(nodeName) {
  !false ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + "If you're seeing this, this is likely a bug in Relay.", nodeName) : invariant(false) : void 0;
}

function createFragmentResource(environment) {
  return new FragmentResourceImpl(environment);
}

var dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();

function getFragmentResourceForEnvironment(environment) {
  var cached = dataResources.get(environment);

  if (cached) {
    return cached;
  }

  var newDataResource = createFragmentResource(environment);
  dataResources.set(environment, newDataResource);
  return newDataResource;
}

module.exports = {
  createFragmentResource: createFragmentResource,
  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment
};